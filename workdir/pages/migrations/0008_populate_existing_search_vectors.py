# Generated by Django 5.2.2 on 2025-06-09 11:13

from django.db import migrations
from django.db.models import Value
from django.contrib.postgres.search import SearchVector

# Helper function to extract text from ProseMirror JSON (copied from models.py for self-containment)
def prosemirror_json_to_text_for_migration(json_content):
    if not isinstance(json_content, dict) or 'content' not in json_content:
        return ''
    text_parts = []
    def extract_text_recursive(nodes):
        for node in nodes:
            if node.get('type') == 'text' and 'text' in node:
                text_parts.append(node['text'])
            if 'content' in node and isinstance(node['content'], list):
                extract_text_recursive(node['content'])
    extract_text_recursive(json_content['content'])
    return ' '.join(text_parts)

def populate_search_vectors(apps, schema_editor):
    Page = apps.get_model('pages', 'Page')
    db_alias = schema_editor.connection.alias

    # Iterate over pages and update search_vector one by one
    # This is safer for large datasets than .update() with SearchVector function directly in older Django
    # However, for Django 3.2+ .update() with SearchVector is generally fine.
    # Let's try direct update first for efficiency.

    # Efficient way using .update() - requires Django 2.2+ for SearchVector in update
    # For older versions, loop and save might be needed.
    # The models.Value() is important if plain_content is not a field name.
    # However, we cannot directly call instance.content_json or the helper in an .update() F() object style.
    # So, we must iterate.

    pages_to_update = Page.objects.using(db_alias).all()
    updated_count = 0
    for page in pages_to_update:
        plain_content = prosemirror_json_to_text_for_migration(page.content_json)
        # Update the search_vector for each page
        # Using SearchVector directly in the .update() call for an individual instance
        page.search_vector = SearchVector(Value(page.title, output_field=models.TextField()), weight='A') + \
                             SearchVector(Value(plain_content, output_field=models.TextField()), weight='B')
        page.save(using=db_alias, update_fields=['search_vector'])
        updated_count +=1

    if updated_count > 0:
        print(f"\nPopulated search_vector for {updated_count} pages.")


def reverse_populate_search_vectors(apps, schema_editor):
    # This operation is technically reversible by clearing the field,
    # but the data (specific vectors) isn't perfectly reversible to its previous state (e.g. NULL).
    # For simplicity, we can just set them to NULL.
    Page = apps.get_model('pages', 'Page')
    db_alias = schema_editor.connection.alias
    Page.objects.using(db_alias).update(search_vector=None)
    print("\nCleared search_vector for all pages.")


class Migration(migrations.Migration):

    dependencies = [
        ('pages', '0007_page_search_vector_and_more'),
    ]

    operations = [
        migrations.RunPython(populate_search_vectors, reverse_populate_search_vectors),
    ]
